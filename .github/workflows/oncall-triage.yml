name: Oncall Issue Triage
description: Automatically identify and label critical blocking issues requiring oncall attention
on:
  push:
    branches:
      - add-oncall-triage-workflow  # Temporary: for testing only
  schedule:
    # Run every 6 hours
    - cron: '0 */6 * * *'
  workflow_dispatch: # Allow manual trigger

jobs:
  oncall-triage:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    permissions:
      contents: read
      issues: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Validate environment and permissions
        run: |
          set -e
          echo "::group::Environment validation"
          echo "Validating required environment variables and permissions..."
          
          # Check if GITHUB_TOKEN is available
          if [ -z "${{ secrets.GITHUB_TOKEN }}" ]; then
            echo "::error::GITHUB_TOKEN is not available"
            exit 1
          fi
          
          # Check if ANTHROPIC_API_KEY is available
          if [ -z "${{ secrets.ANTHROPIC_API_KEY }}" ]; then
            echo "::error::ANTHROPIC_API_KEY is not available"
            exit 1
          fi
          
          echo "✓ All required secrets are available"
          echo "✓ Repository: ${{ github.repository }}"
          echo "✓ Workflow run ID: ${{ github.run_id }}"
          echo "::endgroup::"

      - name: Create oncall triage prompt
        run: |
          set -e
          echo "::group::Creating oncall triage prompt"
          mkdir -p /tmp/claude-prompts
          
          if [ ! -d /tmp/claude-prompts ]; then
            echo "::error::Failed to create /tmp/claude-prompts directory"
            exit 1
          fi
          
          cat > /tmp/claude-prompts/oncall-triage-prompt.txt << 'EOF'
          You're an oncall triage assistant for GitHub issues. Your task is to identify critical issues that require immediate oncall attention.

          Important: Don't post any comments or messages to the issues. Your only action should be to apply the "oncall" label to qualifying issues.

          Repository: ${{ github.repository }}

          Task overview:
          1. Fetch all open issues updated in the last 3 days:
             - Use mcp__github__list_issues with:
               - state="open"
               - first=5 (fetch only 5 issues per page)
               - orderBy="UPDATED_AT"
               - direction="DESC"
             - This will give you the most recently updated issues first
             - For each page of results, check the updatedAt timestamp of each issue
             - Add issues updated within the last 3 days (72 hours) to your TODO list as you go
             - Keep paginating using the 'after' parameter until you encounter issues older than 3 days
             - Once you hit issues older than 3 days, you can stop fetching (no need to fetch all open issues)

          2. Build your TODO list incrementally as you fetch:
             - As you fetch each page, immediately add qualifying issues to your TODO list
             - One TODO item per issue number (e.g., "Evaluate issue #123")
             - This allows you to start processing while still fetching more pages

          3. For each issue in your TODO list:
             - Use mcp__github__get_issue to read the issue details (title, body, labels)
             - Use mcp__github__get_issue_comments to read all comments
             - Evaluate whether this issue needs the oncall label:
               a) Is it a bug? (has "bug" label or describes bug behavior)
               b) Does it have at least 50 engagements? (count comments + reactions)
               c) Is it truly blocking? Read and understand the full content to determine:
                  - Does this prevent core functionality from working?
                  - Can users work around it?
                  - Consider severity indicators: "crash", "stuck", "frozen", "hang", "unresponsive", "cannot use", "blocked", "broken"
                  - Be conservative - only flag issues that truly prevent users from getting work done

          4. For issues that meet all criteria and do not already have the "oncall" label:
             - Use mcp__github__update_issue to add the "oncall" label
             - Do not post any comments
             - Do not remove any existing labels
             - Do not remove the "oncall" label from issues that already have it

          Important guidelines:
          - Use the TODO list to track your progress through ALL candidate issues
          - Process issues efficiently - don't read every single issue upfront, work through your TODO list systematically
          - Be conservative in your assessment - only flag truly critical blocking issues
          - Do not post any comments to issues
          - Your only action should be to add the "oncall" label using mcp__github__update_issue
          - Mark each issue as complete in your TODO list as you process it

          7. After processing all issues in your TODO list, provide a summary of your actions:
             - Total number of issues processed (candidate issues evaluated)
             - Number of issues that received the "oncall" label
             - For each issue that got the label: list issue number, title, and brief reason why it qualified
             - Close calls: List any issues that almost qualified but didn't quite meet the criteria (e.g., borderline blocking, had workarounds)
             - If no issues qualified, state that clearly
             - Format the summary clearly for easy reading
          EOF

      - name: Setup GitHub MCP Server
        run: |
          mkdir -p /tmp/mcp-config
          cat > /tmp/mcp-config/mcp-servers.json << 'EOF'
          {
            "mcpServers": {
              "github": {
                "command": "docker",
                "args": [
                  "run",
                  "-i",
                  "--rm",
                  "-e",
                  "GITHUB_PERSONAL_ACCESS_TOKEN",
                  "ghcr.io/github/github-mcp-server:sha-7aced2b"
                ],
                "env": {
                  "GITHUB_PERSONAL_ACCESS_TOKEN": "${{ secrets.GITHUB_TOKEN }}"
                }
              }
            }
          }
          EOF
          
          # Validate MCP config file was created
          if [ ! -f /tmp/mcp-config/mcp-servers.json ]; then
            echo "::error::Failed to create mcp-servers.json"
            exit 1
          fi
          
          echo "✓ MCP Server configuration created successfully"
          echo "Config size: $(wc -c < /tmp/mcp-config/mcp-servers.json) bytes"
          echo "::endgroup::"

      - name: Pull Docker image for GitHub MCP Server
        run: |
          set -e
          echo "::group::Pulling Docker image for GitHub MCP Server"
          
          # Pull the Docker image with retry logic
          max_retries=3
          retry_count=0
          
          while [ $retry_count -lt $max_retries ]; do
            echo "Attempting to pull Docker image (attempt $((retry_count + 1))/$max_retries)..."
            if docker pull ghcr.io/github/github-mcp-server:sha-7aced2b; then
              echo "✓ Docker image pulled successfully"
              docker images | grep github-mcp-server || true
              echo "::endgroup::"
              exit 0
            fi
            
            retry_count=$((retry_count + 1))
            if [ $retry_count -lt $max_retries ]; then
              echo "::warning::Pull failed, retrying in 5 seconds..."
              sleep 5
            fi
          done
          
          echo "::error::Failed to pull Docker image after $max_retries attempts"
          exit 1

      - name: Run Claude Code for Oncall Triage
        id: claude_triage
        uses: anthropics/claude-code-base-action@beta
        continue-on-error: true
        with:
          prompt_file: /tmp/claude-prompts/oncall-triage-prompt.txt
          allowed_tools: "mcp__github__list_issues,mcp__github__get_issue,mcp__github__get_issue_comments,mcp__github__update_issue"
          timeout_minutes: "10"
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          mcp_config: /tmp/mcp-config/mcp-servers.json
          claude_env: |
            GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Validate Claude execution output
        if: always()
        run: |
          set +e
          echo "::group::Validating Claude execution output"
          
          # Check if claude-execution-output.json exists
          if [ -f claude-execution-output.json ]; then
            echo "✓ claude-execution-output.json found"
            echo "Output file size: $(wc -c < claude-execution-output.json) bytes"
            
            # Validate JSON syntax
            if jq empty claude-execution-output.json 2>/dev/null; then
              echo "✓ Output file is valid JSON"
              
              # Display summary if available
              if jq -e '.summary' claude-execution-output.json >/dev/null 2>&1; then
                echo "Summary from Claude execution:"
                jq -r '.summary' claude-execution-output.json || echo "Unable to extract summary"
              fi
            else
              echo "::warning::Output file is not valid JSON"
              echo "First 500 characters of output:"
              head -c 500 claude-execution-output.json || true
            fi
          else
            echo "::warning::claude-execution-output.json not found"
            echo "Listing files in current directory:"
            ls -la || true
          fi
          
          # Check Claude step status
          if [ "${{ steps.claude_triage.outcome }}" != "success" ]; then
            echo "::warning::Claude execution did not complete successfully"
            echo "Outcome: ${{ steps.claude_triage.outcome }}"
          else
            echo "✓ Claude execution completed successfully"
          fi
          
          echo "::endgroup::"
      
      - name: Handle errors and cleanup
        if: failure()
        run: |
          echo "::group::Error handling and cleanup"
          echo "::error::Workflow failed - gathering diagnostic information"
          
          echo "Checking Docker status:"
          docker ps -a || true
          
          echo "Checking available disk space:"
          df -h || true
          
          echo "Checking system resources:"
          free -h || true
          
          echo "Checking recent Docker logs (if any):"
          docker logs $(docker ps -lq) 2>&1 | tail -100 || echo "No Docker containers found"
          
          echo "::endgroup::"
